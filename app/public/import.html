<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Import Questions - Test Builder</title>
    <link rel="stylesheet" href="/public/styles.css" />
    <style>
      body {
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #06b6d4 50%, #10b981 75%, #667eea 100%);
        min-height: 100vh;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, sans-serif;
      }
      .container {
        max-width: 1400px;
        width: 95%;
        margin: 20px auto;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        padding: 24px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.15);
      }
      h2 {
        margin-top: 0;
        margin-bottom: 20px;
        color: #111827;
      }
      .form-section {
        margin-bottom: 20px;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin-bottom: 16px;
      }
      label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
        color: #374151;
        font-size: 14px;
      }
      input {
        width: 100%;
        padding: 10px;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        font-size: 14px;
        box-sizing: border-box;
      }
      input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      textarea {
        width: 100%;
        min-height: 300px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        padding: 12px;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        font-size: 13px;
        resize: vertical;
        box-sizing: border-box;
      }
      textarea:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      .token-section {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #e5e7eb;
      }
      .token-controls {
        display: flex;
        align-items: flex-end;
        gap: 12px;
        flex-wrap: wrap;
      }
      .token-input-group {
        width: 33.333%;
        min-width: 200px;
      }
      .token-generate-group {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .segmented { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
      .bottom-actions {
        margin-top: 24px;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 16px;
        flex-wrap: wrap;
      }
      .token-section-left {
        flex: 1;
        min-width: 400px;
      }
      .import-button-right {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .notice {
        margin-top: 12px;
        padding: 12px;
        border-radius: 8px;
        font-size: 14px;
        line-height: 1.5;
      }
      .notice.success {
        background-color: #ecfdf5;
        color: #065f46;
        border: 1px solid #bbf7d0;
      }
      .notice.error {
        background-color: #fef2f2;
        color: #991b1b;
        border: 1px solid #fecaca;
      }
      /* Instant tooltip */
      .tip {
        position: relative;
        display: inline-block;
      }
      .tip::after {
        content: attr(data-tip);
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        bottom: 125%;
        background: #111827;
        color: white;
        padding: 8px 10px;
        border-radius: 6px;
        white-space: pre-wrap;
        min-width: 260px;
        max-width: 520px;
        font-size: 13px;
        line-height: 1.4;
        box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.1s ease;
        z-index: 20;
      }
      .tip::before {
        content: "";
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        bottom: 118%;
        border: 6px solid transparent;
        border-top-color: #111827;
        opacity: 0;
        transition: opacity 0.1s ease;
        z-index: 20;
      }
      .tip:hover::after,
      .tip:hover::before {
        opacity: 1;
      }
      .tip-icon {
        cursor: help;
        margin-left: 6px;
        display: inline-block;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 1px solid #e5e7eb;
        text-align: center;
        line-height: 18px;
        font-weight: 700;
        font-size: 12px;
        background: #f9fafb;
        color: #6b7280;
      }
      .tip-icon:hover {
        background: #f3f4f6;
        border-color: #d1d5db;
      }
    </style>
  </head>
  <body>
    <header class="header">
      <div class="nav-bar" style="max-width:1400px; margin:0 auto; padding:0 8px;">
        <div class="nav-left">
          <a href="/public/index.html" class="brand" title="Home">
            <span class="logo-icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 7l9-4 9 4-9 4-9-4z" fill="currentColor" style="color: var(--accent);"/>
                <path d="M5 10v6c0 .6.4 1 1 1l6 3 6-3c.6 0 1-.4 1-1v-6" stroke="#4B5563" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </span>
            <span class="brand-text"><span class="accent">Study</span> Buddy</span>
          </a>
        </div>
        <nav class="nav-center">
          <a id="nav-home" class="btn" href="/public/index.html">Home</a>
          <a id="nav-notes" class="btn" href="/public/notes.html">Notes</a>
          <a id="nav-flash" class="btn" href="/public/flashcards.html">Flashcards</a>
          <a id="nav-tests" class="btn" href="/public/index.html#tests">Tests</a>
        </nav>
        <div class="nav-right">
          <a class="btn primary" href="/public/import.html">+ Import JSON</a>
        </div>
      </div>
    </header>
    <div class="container">
      <h2>Import Content (Questions or Flashcards)</h2>
      
      <div class="form-section">
        <div class="row">
          <div>
            <label>Content Type</label>
            <div class="segmented">
              <button type="button" class="btn" id="typeNotes">Notes</button>
              <button type="button" class="btn primary" id="typeQuestions">Questions</button>
              <button type="button" class="btn" id="typeFlashcards">Flashcards</button>
            </div>
            <input type="hidden" id="contentType" value="questions" />
          </div>
          <div>
            <label>Category</label>
            <input id="category" placeholder="e.g., Computer Science" />
          </div>
          <div>
            <label>Subcategory</label>
            <input id="subcategory" placeholder="e.g., Network Protocols" />
          </div>
        </div>
      </div>

      <div class="form-section">
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
          <label style="margin-bottom: 0;" id="jsonLabel">Questions JSON Array</label>
        </div>
        <div id="chatgptPrompt" style="display: none; margin-bottom: 12px; padding: 12px; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px;">
          <div style="margin-bottom: 8px;">
            <label style="display: block; margin-bottom: 6px; font-weight: 600; color: #0369a1; font-size: 13px;">
              Paste your study material (will be merged into a hidden prompt and copied):
            </label>
            <textarea id="userContent" placeholder="Paste your study material here..." style="width: 100%; min-height: 150px; font-family: ui-sans-serif, system-ui, sans-serif; font-size: 13px; padding: 10px; border: 1px solid #bae6fd; border-radius: 6px; background: white; resize: vertical; box-sizing: border-box; pointer-events: auto; cursor: text;" autofocus></textarea>
          </div>
          <div style="display:flex; gap:8px; align-items:center; justify-content:flex-end;">
            <button class="btn primary" id="copyFullPromptBtn" style="font-size: 13px; padding: 6px 12px;" disabled>ðŸ“‹ Copy ChatGPT Prompt</button>
            <a href="https://chatgpt.com" target="_blank" class="btn" style="font-size: 13px; padding: 6px 12px;">Open ChatGPT â†’</a>
          </div>
        </div>
        <div id="jsonWrapper" style="position: relative; min-height:300px;">
          <textarea id="json" placeholder='[
  {"id":"...","question":"...","choices":["A","B"],"answerIndex":0,"explanation":"...","difficulty":"easy"}
]' disabled style="background:#f3f4f6; cursor:not-allowed;"></textarea>
          <div id="loadOverlay" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; gap:8px; background:rgba(243,244,246,0.85); border:1px dashed #c7c9cf; border-radius:8px;">
            <div style="font-size:13px; color:#374151; margin:0;">Choose how you want to provide content</div>
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
              <button type="button" class="btn primary" id="btnLoadJson">Paste Formatted JSON</button>
              <button type="button" class="btn" id="btnLoadRaw">Paste Raw Study Material</button>
            </div>
          </div>
        </div>
      </div>

      <div class="bottom-actions">
        <div class="token-section-left">
          <div class="token-section">
            <label>
              Import Token (optional if server configured)
              <span class="tip tip-icon" data-tip="Why this matters: prevents drive-by imports from other websites (CSRF) and stops anything on your machine from silently posting to this endpoint.&#10;&#10;How to use: start the server with IMPORT_TOKEN set to a secret, then paste the same value here. If no token is set on the server, leave this blank.">?</span>
            </label>
            <div class="token-controls">
              <div class="token-input-group">
                <input id="token" placeholder="Set IMPORT_TOKEN env on server and paste here" />
              </div>
              <div class="token-generate-group">
                <button class="btn" id="genToken">Generate 32â€‘char token</button>
              </div>
            </div>
          </div>
        </div>
        
        <div class="import-button-right">
          <a class="btn" href="/">Back</a>
          <button class="btn primary" id="importBtn" disabled>Import</button>
        </div>
      </div>

      <div class="notice" id="notice"></div>
    </div>
    <script>
      (function setActive(){
        const el = document.getElementById('nav-home');
        if (el) el.classList.add('active');
      })();
      function generateToken() {
        const bytes = new Uint8Array(24);
        if (window.crypto && window.crypto.getRandomValues) {
          window.crypto.getRandomValues(bytes);
        } else {
          for (let i = 0; i < bytes.length; i++) bytes[i] = Math.floor(Math.random() * 256);
        }
        const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 32);
        return hex;
      }

      const chatgptPromptTemplateQuestions = `Convert the following text content into a JSON array of multiple-choice questions in the exact format specified below.

JSON Format Requirements:
- Each question must be an object in a JSON array
- Each question object must have these fields:
  * "id": A unique identifier (string, lowercase with hyphens, e.g., "docker-image-definition")
  * "question": The question text (string)
  * "choices": An array of 2-6 answer choices (array of strings)
  * "answerIndex": The 0-based index of the correct answer in the choices array (number: 0, 1, 2, etc.)
  * "explanation": An explanation of why the answer is correct (string, optional but recommended)
  * "difficulty": One of "easy", "medium", or "hard" (string, optional)
- The output must be a valid JSON array starting with [ and ending with ]

Instructions:
1. Extract or generate multiple-choice questions from the text below
2. Create plausible incorrect answer choices (distractors) for each question
3. Assign appropriate difficulty levels (easy/medium/hard) based on complexity
4. Generate clear, concise explanations for each correct answer
5. Ensure each question has a unique, descriptive ID
6. Output ONLY the JSON array, no additional text or markdown formatting

Text content to convert:

{{USER_CONTENT}}

Output the JSON array now:`;

      const chatgptPromptTemplateNotes = `Convert the following study material into a JSON array of notes where the markdown strictly follows this app's formatting rules.

Output Format (JSON array):
- Each note is an object with EXACTLY these fields:
  * "title": Human-readable title for the note (string)
  * "slug": Kebab-case identifier (string, e.g., "docker-architecture")
  * "markdown": The complete note content as Markdown (string)

Markdown Rules (must follow for consistent rendering):
- Start with a single H1: "# {Title}"
- Use "##" for major sections and "###" for subsections
- No manual Table of Contents; the app auto-generates it from H1/H2/H3
- Code examples MUST use fenced code blocks with language tags supported by the app.
- Example (YAML):
  \`\`\`yaml
  # code here
  \`\`\`
- Use triple backticks with the language immediately after (no extra spaces)
- Prefer small, focused examples; do not include screenshots or images
- Avoid ASCII art diagrams (language-text) unless absolutely necessary
- Use lists with "- " for bullets and standard numbered lists for steps
- Use inline code with single backticks for identifiers (e.g., \`kubectl\`)
- Keep lines readable; long code lines are okay (the app scrolls horizontally)
- Tables are allowed in plain Markdown if useful

Content Guidance:
- Begin with a short overview explaining the â€œwhyâ€ in laymanâ€™s terms
- Cover architecture and key components
- Include common pitfalls and best practices
- End with a brief â€œKey Takeawaysâ€ section

Instructions:
1. Extract and structure the content into clear sections using H2/H3
2. Add concise, runnable examples using proper fenced code blocks with language tags
3. Do NOT include any text outside of the JSON array output

Text content to convert:

{{USER_CONTENT}}

Output the JSON array now:`;

      const chatgptPromptTemplateFlashcards = `Convert the following text content into a JSON array of flashcards in the exact format specified below.

JSON Format Requirements:
- Each flashcard must be an object in a JSON array
- Each flashcard object must have these fields:
  * "id": A unique identifier (string, lowercase with hyphens, e.g., "socket-definition")
  * "term": The concept or term (string)
  * "definition": A concise definition for study (string)
- Optional fields allowed:
  * "tags": array of strings
  * "source": string (e.g., note path or URL)
- The output must be a valid JSON array starting with [ and ending with ]

Instructions:
1. Extract important terms and their definitions from the text below
2. Keep definitions short, precise, and exam-friendly
3. Ensure each flashcard has a unique, descriptive ID
4. Output ONLY the JSON array, no additional text or markdown formatting

Text content to convert:

{{USER_CONTENT}}

Output the JSON array now:`;

      function buildPromptWithContent() {
        const userContent = document.getElementById('userContent').value.trim();
        const type = document.getElementById('contentType').value;
        const tmpl = type === 'flashcards'
          ? chatgptPromptTemplateFlashcards
          : (type === 'notes' ? chatgptPromptTemplateNotes : chatgptPromptTemplateQuestions);
        if (!userContent) {
          return tmpl.replace('{{USER_CONTENT}}', '[PASTE YOUR STUDY MATERIAL HERE]');
        }
        return tmpl.replace('{{USER_CONTENT}}', userContent);
      }

      function updatePromptPreview() {
        const promptTextarea = document.getElementById('promptText');
        promptTextarea.value = buildPromptWithContent();
      }

      // Enable/disable Copy Prompt based on raw content presence
      (function gateCopyPrompt(){
        const raw = document.getElementById('userContent');
        const copyBtn = document.getElementById('copyFullPromptBtn');
        if (raw && copyBtn) {
          const sync = () => { copyBtn.disabled = raw.value.trim().length === 0; };
          raw.addEventListener('input', sync);
          sync();
        }
      })();

      // Overlay actions
      (function bindOverlay(){
        const overlay = document.getElementById('loadOverlay');
        const jsonArea = document.getElementById('json');
        const btnJson = document.getElementById('btnLoadJson');
        const btnRaw = document.getElementById('btnLoadRaw');
        const promptSection = document.getElementById('chatgptPrompt');
        if (btnJson && overlay && jsonArea) {
          btnJson.addEventListener('click', () => {
            overlay.style.display = 'none';
            jsonArea.disabled = false;
            jsonArea.style.background = 'white';
            jsonArea.style.cursor = 'text';
            jsonArea.focus();
          });
        }
        if (btnRaw && overlay && promptSection) {
          btnRaw.addEventListener('click', () => {
            overlay.style.display = 'none';
            promptSection.style.display = 'block';
            const uc = document.getElementById('userContent');
            if (uc) uc.focus();
            updatePromptPreview();
            const notice = document.getElementById('notice');
            if (notice) {
              notice.textContent = 'Paste your study material, then click "Copy ChatGPT Prompt". Next, paste ChatGPT output into the JSON box to validate.';
              notice.className = 'notice success';
            }
          });
        }
      })();

      // Schema validators per content type
      function validateArrayForType(type, data) {
        if (!Array.isArray(data)) return { valid:false, errors:['Root must be a JSON array'] };
        const errors = [];
        if (type === 'flashcards') {
          data.forEach((c, i) => {
            if (!c || typeof c !== 'object') errors.push(`Item ${i}: must be object`);
            if (!c.id || typeof c.id !== 'string') errors.push(`Item ${i}: missing id`);
            if (!c.term || typeof c.term !== 'string') errors.push(`Item ${i}: missing term`);
            if (!c.definition || typeof c.definition !== 'string') errors.push(`Item ${i}: missing definition`);
          });
        } else if (type === 'notes') {
          data.forEach((n, i) => {
            if (!n || typeof n !== 'object') errors.push(`Item ${i}: must be object`);
            if (!n.title || typeof n.title !== 'string') errors.push(`Item ${i}: missing title`);
            if (!n.slug || typeof n.slug !== 'string') errors.push(`Item ${i}: missing slug`);
            if (!n.markdown || typeof n.markdown !== 'string') errors.push(`Item ${i}: missing markdown`);
          });
        } else { // questions
          data.forEach((q, i) => {
            if (!q || typeof q !== 'object') errors.push(`Item ${i}: must be object`);
            if (!q.id || typeof q.id !== 'string') errors.push(`Item ${i}: missing id`);
            if (!q.question || typeof q.question !== 'string') errors.push(`Item ${i}: missing question`);
            if (!Array.isArray(q.choices) || q.choices.length < 2 || q.choices.length > 6) errors.push(`Item ${i}: choices 2-6 required`);
            if (typeof q.answerIndex !== 'number' || q.answerIndex < 0 || q.answerIndex >= (q.choices ? q.choices.length : 0)) errors.push(`Item ${i}: invalid answerIndex`);
          });
        }
        return { valid: errors.length === 0, errors };
      }

      // Gate Import button based on JSON validity
      (function bindValidation(){
        const jsonArea = document.getElementById('json');
        const importBtn = document.getElementById('importBtn');
        const notice = document.getElementById('notice');
        const contentType = document.getElementById('contentType');
        if (!jsonArea || !importBtn || !contentType) return;
        const run = () => {
          importBtn.disabled = true;
          const raw = jsonArea.value.trim();
          if (!raw) {
            // Reset to initial state when cleared
            const overlay = document.getElementById('loadOverlay');
            if (overlay) overlay.style.display = 'flex';
            jsonArea.disabled = true;
            jsonArea.style.background = '#f3f4f6';
            jsonArea.style.cursor = 'not-allowed';
            const promptSection = document.getElementById('chatgptPrompt');
            if (promptSection) promptSection.style.display = 'none';
            const copyBtn = document.getElementById('copyFullPromptBtn');
            if (copyBtn) copyBtn.disabled = true;
            notice.textContent = '';
            notice.className = 'notice';
            return;
          }
          try {
            const data = JSON.parse(raw);
            const { valid, errors } = validateArrayForType(contentType.value, data);
            if (valid) {
              const cat = document.getElementById('category').value.trim();
              const sub = document.getElementById('subcategory').value.trim();
              if (cat && sub) {
                notice.textContent = 'Data validated â€” ready to import.';
                notice.className = 'notice success';
                importBtn.disabled = false;
              } else {
                notice.textContent = 'Add Category and Subcategory to enable Import.';
                notice.className = 'notice error';
                importBtn.disabled = true;
              }
            } else {
              notice.textContent = 'Validation failed: ' + errors.slice(0,3).join('; ') + (errors.length>3?' ...':'') + ' â€” click "Get ChatGPT Prompt" to convert raw content to valid JSON.';
              notice.className = 'notice error';
            }
          } catch (e) {
            notice.textContent = 'Invalid JSON â€” click "Get ChatGPT Prompt" to convert raw content to valid JSON.';
            notice.className = 'notice error';
          }
        };
        jsonArea.addEventListener('input', run);
        const catEl = document.getElementById('category');
        const subEl = document.getElementById('subcategory');
        if (catEl) catEl.addEventListener('input', run);
        if (subEl) subEl.addEventListener('input', run);
      })();
      // Wire segmented buttons to set content type and update UI
      function setContentType(type) {
        const hidden = document.getElementById('contentType');
        if (hidden) hidden.value = type;

        // Toggle selected button style
        const bNotes = document.getElementById('typeNotes');
        const bQs = document.getElementById('typeQuestions');
        const bFlash = document.getElementById('typeFlashcards');
        if (bNotes && bQs && bFlash) {
          bNotes.classList.toggle('primary', type === 'notes');
          bQs.classList.toggle('primary', type === 'questions');
          bFlash.classList.toggle('primary', type === 'flashcards');
        }

        // Update label/placeholder like the change listener below
        const jsonLabel = document.getElementById('jsonLabel');
        const jsonTextarea = document.getElementById('json');
        if (type === 'flashcards') {
          if (jsonLabel) jsonLabel.textContent = 'Flashcards JSON Array';
          if (jsonTextarea) jsonTextarea.placeholder = '[\n  {"id":"...","term":"...","definition":"...","tags":["optional"],"source":"optional"}\n]';
        } else if (type === 'notes') {
          if (jsonLabel) jsonLabel.textContent = 'Notes JSON Array';
          if (jsonTextarea) jsonTextarea.placeholder = '[\n  {"title":"...","slug":"...","markdown":"# Your note content..."}\n]';
        } else {
          if (jsonLabel) jsonLabel.textContent = 'Questions JSON Array';
          if (jsonTextarea) jsonTextarea.placeholder = '[\n  {"id":"...","question":"...","choices":["A","B"],"answerIndex":0,"explanation":"...","difficulty":"easy"}\n]';
        }
        updatePromptPreview();
      }

      // Initial wiring for segmented buttons
      (function bindTypeButtons(){
        const n = document.getElementById('typeNotes');
        const q = document.getElementById('typeQuestions');
        const f = document.getElementById('typeFlashcards');
        if (n) n.addEventListener('click', () => setContentType('notes'));
        if (q) q.addEventListener('click', () => setContentType('questions'));
        if (f) f.addEventListener('click', () => setContentType('flashcards'));
      })();

      // ChatGPT prompt is hidden by default and only shown when user selects "Paste Raw Study Material" from the overlay

      document.getElementById('copyFullPromptBtn').onclick = async (e) => {
        const btn = e.currentTarget;
        const fullPrompt = buildPromptWithContent();
        try {
          await navigator.clipboard.writeText(fullPrompt);
          const notice = document.getElementById('notice');
          notice.textContent = 'Copied! Open ChatGPT and paste the prompt, then paste the JSON back here to validate.';
          notice.className = 'notice success';
          const prev = btn.textContent;
          btn.textContent = 'âœ… Copied!';
          btn.disabled = true;
          setTimeout(() => { btn.textContent = prev; btn.disabled = false; }, 1500);
        } catch (e) {
          console.error('Failed to copy:', e);
          const notice = document.getElementById('notice');
          notice.textContent = 'Failed to copy. Please copy manually from the generated prompt.';
          notice.className = 'notice error';
        }
      };

      // Update preview when user types/pastes content
      document.getElementById('userContent').addEventListener('input', () => {
        updatePromptPreview();
      });

      document.getElementById('genToken').onclick = async () => {
        const tokenField = document.getElementById('token');
        const t = generateToken();
        tokenField.value = t;
        const notice = document.getElementById('notice');
        try {
          await navigator.clipboard.writeText(`IMPORT_TOKEN="${t}"`);
          notice.textContent = 'Token generated and copied. Add it to your .env (gitignored) as IMPORT_TOKEN, restart the server, then refresh this page and paste the token here (or leave blank if the server loads it).';
          notice.className = 'notice success';
        } catch {
          notice.textContent = 'Token generated. Copy this into your .env as IMPORT_TOKEN, restart the server, then refresh this page.';
          notice.className = 'notice success';
        }
      };

      document.getElementById('importBtn').onclick = async () => {
        const category = document.getElementById('category').value.trim();
        const subcategory = document.getElementById('subcategory').value.trim();
        const raw = document.getElementById('json').value.trim();
        const notice = document.getElementById('notice');
        notice.textContent = '';
        notice.className = 'notice';
        let dataArray;
        try {
          dataArray = JSON.parse(raw);
        } catch(e) {
          notice.textContent = 'Invalid JSON';
          notice.className = 'notice error';
          return;
        }
        if (!Array.isArray(dataArray)) {
          notice.textContent = 'JSON must be an array';
          notice.className = 'notice error';
          return;
        }
        if (!category || !subcategory) {
          notice.textContent = 'Category and Subcategory required';
          notice.className = 'notice error';
          return;
        }
        try {
          const token = document.getElementById('token').value.trim();
          const headers = { 'Content-Type': 'application/json' };
          if (token) headers['x-import-token'] = token;
          const type = document.getElementById('contentType').value;
          const endpoint = type === 'flashcards' ? '/api/import-flashcards' : '/api/import';
          const payload = type === 'flashcards' ? { category, subcategory, cards: dataArray } : { category, subcategory, questions: dataArray };
          const res = await fetch(endpoint, { method: 'POST', headers, body: JSON.stringify(payload) });
          const json = await res.json();
          if (!res.ok) throw new Error(json.error || 'Import failed');
          notice.textContent = 'Imported successfully. Saved to: ' + json.saved;
          notice.className = 'notice success';
          document.getElementById('category').value = '';
          document.getElementById('subcategory').value = '';
          document.getElementById('json').value = '';
        } catch (e) {
          notice.textContent = 'Import failed: ' + (e.message || e);
          notice.className = 'notice error';
        }
      };

      // Update UI labels and placeholders on type change
      document.getElementById('contentType').addEventListener('change', () => {
        const type = document.getElementById('contentType').value;
        const jsonLabel = document.getElementById('jsonLabel');
        const jsonTextarea = document.getElementById('json');
        if (type === 'flashcards') {
          jsonLabel.textContent = 'Flashcards JSON Array';
          jsonTextarea.placeholder = '[\n  {"id":"...","term":"...","definition":"...","tags":["optional"],"source":"optional"}\n]';
        } else if (type === 'notes') {
          jsonLabel.textContent = 'Notes JSON Array';
          jsonTextarea.placeholder = '[\n  {"title":"...","slug":"...","markdown":"# Your note content..."}\n]';
        } else {
          jsonLabel.textContent = 'Questions JSON Array';
          jsonTextarea.placeholder = '[\n  {"id":"...","question":"...","choices":["A","B"],"answerIndex":0,"explanation":"...","difficulty":"easy"}\n]';
        }
        updatePromptPreview();
      });
    </script>
  </body>
  <script>
    (function(){
      ['nav-home','nav-notes','nav-flash','nav-tests'].forEach(id=>{
        const el = document.getElementById(id);
        if (el) el.classList.remove('active');
      });
    })();
  </script>
</html>
